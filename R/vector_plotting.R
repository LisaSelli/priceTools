

######################## Vector Plotting ########################


#' Process single treatment's worth of data for plotting CAFE components.
#'
#' This function takes the data generated by pairwise.price() and processes it into 
#' terms needed in CAFE vector plots.
#'
#' @param data  Pairwise Price data
#' @param group.vars A vector of grouping variables, if any.
#' @param standardize Should ecosystem function values be standardized against baseline
#' 
#' @return A list of three data sets with differen levels of aggregation used in subsequent vector plots.
#' 
#' @examples
#' 
#' # write one
#' 
#' @import dplyr
process.data.cafe<-function(data, group.vars=NULL, standardize=TRUE){
  
  if(standardize == TRUE){
    comps <- c("SRE.L","SRE.G","SCE.L","SCE.G","CDE","SL","SG","SR","CE")
    data[,comps] <- 100*data[,comps]/data$x.func                  # X function scaled
    data$y.func <- 100*(data$y.func - data$x.func)/data$x.func    # Y function scaled
    data$x.func <- 0 # X function set as baseline.
    data$SG <- data$SL + data$SG  # net SG change:
  } else{
    data$x.func <- data$x.func
    data$y.func <- data$y.func
    data$SL <- data$x.func + data$SL
    data$SG <- data$SL + data$SG
  }
  
  # CAFE component    richness    function
  # base = c(x.rich,x.func)
  # SL = c(c.rich,SL)
  # SG = c(y.rich,SL+SG)
  # CDE = c(y.rich,y.func)
  
  cols <- c(group.vars,'x.func','SL','SG','y.func','x.rich','c.rich','y.rich')
  p2 <- reshape2::melt(data[,cols],id.vars=c(group.vars,'x.rich','c.rich','y.rich'))

  # add richness column:
  p2$rich <- ifelse(p2$variable == "x.func", p2$x.rich,
                  ifelse(p2$variable == "SL", p2$c.rich,
                         ifelse(p2$variable == "SG", p2$y.rich,
                                ifelse(p2$variable == "y.func", p2$y.rich, NA))))
  
  # summarize raw points:
  p3b <- p2 %>% group_by(variable) %>% summarise(mean.y=mean(value),
                                                y.qt.lw=quantile(value, probs=0.025),
                                                y.qt.up=quantile(value, probs=0.975),
                                                mean.x=mean(rich),
                                                x.qt.lw=quantile(rich, probs=0.025),
                                                x.qt.up=quantile(rich, probs=0.975))
  
  # stagger rows:
  p3b2 <- p3b
  nms <- p3b2$variable[2:4]
  p3b2 <- p3b2[1:3,]
  p3b2$variable <- nms
  p4 <- rbind(p3b, p3b2)
  p4 <- p4[p4$variable != "x.func",]
  
  # Organize factor levels for plotting:
  p2$variable <- factor(p2$variable,levels=c("x.func","SL","SG","y.func"),
                          labels=c("baseline","SL","SG","comparison"))
  p3b$variable <- factor(p3b$variable,levels=c("x.func","SL","SG","y.func"),
                          labels=c("baseline","SL","SG","comparison"))
  p4$variable <- factor(p4$variable,levels=c("SL","SG","y.func"),
                          labels=c("SL vector","SG vector","CDE vector"))
  
  p2$variable <- factor(p2$variable, levels=c("baseline","SL","SG","comparison",
                                             "SL vector","SG vector","CDE vector"))
  p3b$variable <- factor(p3b$variable, levels=c("baseline","SL","SG","comparison",
                                               "SL vector","SG vector","CDE vector"))
  p4$variable <- factor(p4$variable, levels=c("baseline","SL","SG","comparison",
                                             "SL vector","SG vector","CDE vector"))
  
  p3b <- p3b[p3b$variable != "baseline",]
  
  return(list(p2, p3b, p4))
}


#' Process single treatment's worth of data for plotting BEF components.
#'
#' This function takes the data generated by pairwise.price() and processes it into 
#' terms needed in BEF vector plots.
#'
#' @param data  Pairwise Price data
#' @param group.vars A vector of grouping variables, if any.
#' @param standardize Should ecosystem function values be standardized against baseline
#' 
#' @return A list of three data sets with differen levels of aggregation used in subsequent vector plots.
#' 
#' @examples
#' 
#' # write one
#'
#' @import dplyr 
process.data.bef<-function(data, group.vars=NULL, standardize=TRUE){
  
  if(standardize == TRUE){
    comps <- c("SRE.L","SRE.G","SCE.L","SCE.G","CDE","SL","SG","SR","CE")
    data[,comps] <- 100*data[,comps]/data$x.func                  # X function scaled
    data$y.func <- 100*(data$y.func - data$x.func)/data$x.func    # Y function scaled
    data$x.func <- 0     # X function set as baseline.
  } else{
    data$x.func <- data$x.func
    data$y.func <- data$y.func
    data$SR <- data$x.func + data$SR
  }
  
  # BEF component
  # base = c(x.rich,x.func)
  # SR = c(x.rich,x.func + SRE.L + SRE.G)
  # CE = c(y.rich,y.func) = c(y.rich, x.func + SRE.L + SRE.G + SCEs + CDE)
  
  cols <- c(group.vars,'x.func','SR','y.func','x.rich','c.rich','y.rich')
  p2 <- reshape2::melt(data[,cols], id.vars=c(group.vars,'x.rich','c.rich','y.rich'))

  # add composite richness column:
  p2$rich <- ifelse(p2$variable == "x.func", p2$x.rich,
                  ifelse(p2$variable == "SR", p2$y.rich,
                         ifelse(p2$variable == "y.func", p2$y.rich, NA)))
  
  # summarize raw points:
  p3b <- p2 %>% group_by(variable) %>% summarise(mean.y=mean(value),
                                                y.qt.lw=quantile(value, probs=0.025),
                                                y.qt.up=quantile(value, probs=0.975),
                                                mean.x=mean(rich),
                                                x.qt.lw=quantile(rich, probs=0.025),
                                                x.qt.up=quantile(rich, probs=0.975))
  
  # stagger rows:
  p3b2 <- p3b
  nms <- p3b2$variable[2:3]
  p3b2 <- p3b2[1:2,]
  p3b2$variable <- nms
  p4 <- rbind(p3b, p3b2)
  p4 <- p4[p4$variable != "x.func",]
  
  # Organize factor levels for plotting:
  p2$variable <- factor(p2$variable,levels=c("x.func","SR","y.func"),
                          labels=c("baseline","SR","comparison"))
  p3b$variable <- factor(p3b$variable,levels=c("x.func","SR","y.func"),
                          labels=c("baseline","SR","comparison"))
  p4$variable <- factor(p4$variable,levels=c("SR","y.func"),
                          labels=c("SR vector","CE vector"))
  
  p2$variable <- factor(p2$variable,levels=c("baseline","SR","comparison","SR vector",
                                            "CE vector"))
  p3b$variable <- factor(p3b$variable,levels=c("baseline","SR","comparison","SR vector",
                                            "CE vector"))
  p4$variable <- factor(p4$variable,levels=c("baseline","SR","comparison","SR vector",
                                            "CE vector"))
  
  p3b <- p3b[p3b$variable != "baseline",]
  
  return(list(p2, p3b, p4))
}


#' Process single treatment's worth of data for plotting 5-part Price components.
#'
#' This function takes the data generated by pairwise.price() and processes it into 
#' terms needed in CAFE vector plots.
#'
#' @param data  Pairwise Price data
#' @param group.vars A vector of grouping variables, if any.
#' @param standardize Should ecosystem function values be standardized against baseline
#' 
#' @return A list of three data sets with differen levels of aggregation used in subsequent vector plots.
#' 
#' @examples
#' 
#' # write one
#' 
#' @import dplyr
process.data.price<-function(data,group.vars=NULL,standardize=TRUE){
  
  ### standardize
  if(standardize == TRUE){
    comps <- c("SRE.L","SRE.G","SCE.L","SCE.G","CDE")
    data[,comps] <- 100*data[,comps]/data$x.func                  # X function scaled
    data$y.func <- 100*(data$y.func - data$x.func)/data$x.func    # Y function scaled
    data$x.func <- 0     # X function set as baseline.
    data$SCE.L <- data$SRE.L + data$SCE.L  # create net change vectors
    data$SRE.G <- data$SCE.L + data$SRE.G
    data$SCE.G <- data$SRE.G + data$SCE.G
  } else{
    data$x.func <- data$x.func
    data$y.func <- data$y.func
    data$SRE.L <- data$x.func + data$SRE.L
    data$SCE.L <- data$SRE.L + data$SCE.L
    data$SRE.G <- data$SCE.L + data$SRE.G
    data$SCE.G <- data$SRE.G + data$SCE.G
  }
  
  # base = c(x.rich,x.func)
  # SRE.L = c(c.rich,0 + SRE.L)
  # SCE.L = c(c.rich,0 + SRE.L + SCE.L = SL)
  # SRE.G = c(y.rich,0 + SRE.L + SCE.L + SRE.G = SL + SRE.G)
  # SCE.G = c(y.rich,0 + SRE.L + SCE.L + SRE.G + SCE.G = SL + SG)
  # CDE = c(y.rich,y.func)
  
  cols <- c(group.vars,'x.func','SRE.L','SCE.L','SRE.G','SCE.G',
                'y.func','x.rich','c.rich','y.rich')
  p2 <- reshape2::melt(data[,cols], id.vars=c(group.vars,'x.rich','c.rich','y.rich'))
  
  # add richness column:
  p2$rich<-ifelse(p2$variable == "x.func", p2$x.rich,
                  ifelse(p2$variable == "SRE.L", p2$c.rich,
                         ifelse(p2$variable == "SCE.L", p2$c.rich,
                                ifelse(p2$variable == "SRE.G", p2$y.rich,
                                       ifelse(p2$variable == "SCE.G", p2$y.rich,
                                              ifelse(p2$variable == "y.func", p2$y.rich, NA)
                                              )
                                       )
                                )
                         )
                  )
  
  # summarize raw points:
  p3b <- p2 %>% group_by(variable) %>% summarise(mean.y=mean(value),
                                                y.qt.lw=quantile(value, probs=0.025),
                                                y.qt.up=quantile(value, probs=0.975),
                                                mean.x=mean(rich),
                                                x.qt.lw=quantile(rich, probs=0.025),
                                                x.qt.up=quantile(rich, probs=0.975))
  
  # stagger rows:
  p3b2 <- p3b
  nms <- p3b2$variable[2:6]
  p3b2 <- p3b2[1:5,]
  p3b2$variable <- nms
  p4 <- rbind(p3b,p3b2)
  p4 <- p4[p4$variable != "x.func",]
  
  # Organize factor levels for plotting:
  p2$variable <- factor(p2$variable, levels=c("x.func","SRE.L","SCE.L","SRE.G","SCE.G",
                                              "y.func"),
                        labels=c("baseline","SRE.L","SCE.L","SRE.G","SCE.G","comparison"))
  p3b$variable <- factor(p3b$variable, levels=c("x.func","SRE.L","SCE.L","SRE.G","SCE.G",
                                                "y.func"),
                        labels=c("baseline","SRE.L","SCE.L","SRE.G","SCE.G","comparison"))
  p4$variable <- factor(p4$variable, levels=c("SRE.L","SCE.L","SRE.G","SCE.G","y.func"),
                        labels=c("SRE.L vector","SCE.L vector","SRE.G vector",
                                 "SCE.G vector","CDE vector"))
  
  p2$variable <- factor(p2$variable, levels=c("baseline","SRE.L","SCE.L","SRE.G","SCE.G",
                                              "comparison","SRE.L vector","SCE.L vector",
                                              "SRE.G vector","SCE.G vector","CDE vector"))
  p3b$variable <- factor(p3b$variable, levels=c("baseline","SRE.L","SCE.L","SRE.G","SCE.G",
                                               "comparison","SRE.L vector","SCE.L vector",
                                               "SRE.G vector","SCE.G vector","CDE vector"))
  p4$variable <- factor(p4$variable, levels=c("baseline","SRE.L","SCE.L","SRE.G","SCE.G",
                                             "comparison","SRE.L vector","SCE.L vector",
                                             "SRE.G vector","SCE.G vector","CDE vector"))
  
  p3b <- p3b[p3b$variable != "baseline",]
  
  return(list(p2, p3b, p4))
}


#' Plot changes in ecosystem function between communities as vector diagram.
#'
#' This wrapper function takes the data generated by \code{\link{pairwise.price()}} and produces vector plots using either BEF, CAFE, or 5-part Price components.
#'
#' @param data Pairwise Price data
#' @param type Specify the type of vector diagram to draw ("cafe","bef","both", or "price")
#' @param group.vars A vector of grouping variables, if any
#' @param standardize Should ecosystem function values be standardized against baseline
#' @param ... Additional graphical options passed to lower-level functions. See \code{\link{leap.zig.bef}}, \code{\link{leap.zig.cafe}}, \code{\link{leap.zig.both}}, \code{\link{leap.zig.price}}
#' 
#' @return A ggplot object.
#' 
#' @examples
#' 
#' # write one
#'
#' @export
leap.zig<-function(data, type="cafe", group.vars=NULL, standardize=TRUE, ...){
  
  switch(type,
         cafe={
           tmp <- process.data.cafe(data, group.vars, standardize)
           leap.zig.cafe(tmp, loc.standardize=standardize, ...)
         },
         bef={
           tmp <- process.data.bef(data, group.vars, standardize)
           leap.zig.bef(tmp, loc.standardize=standardize, ...)
         },
         both={
           tmp <- process.data.cafe(data, group.vars, standardize)
           tmp.bef <- process.data.bef(data, group.vars, standardize)
           
           tmp[[1]] <- unique(rbind(tmp[[1]], tmp.bef[[1]]))
           tmp[[2]] <- unique(rbind(tmp[[2]], tmp.bef[[2]]))
           tmp[[3]] <- unique(rbind(tmp[[3]], tmp.bef[[3]]))
           
           lvls <- c("baseline","SL","SG","SR","comparison","SL vector","SG vector","CDE vector",
                     "SR vector","CE vector")
           tmp[[1]]$variable <- factor(tmp[[1]]$variable, levels=lvls)
           leap.zig.both(tmp, loc.standardize=standardize, ...)
         },
         price={
           tmp <- process.data.price(data,group.vars, standardize)
           leap.zig.price(tmp, loc.standardize=standardize, ...)
         },
         "Error! Invalid plot method in leap.zig()"
  )
}


#' Plot changes in ecosystem function using CAFE & BEF components.
#'
#' This function is called by \code{\link{leap.zig()}} and produces vector plots 
#' using BEF and CAFE components, overlaid on top of each other.
#'
#' @param tmp   Data to plot
#' @param xlim  Plot's x limits
#' @param ylim  Plot's y limits
#' @param loc.standarize  Are these standardized vectors
#' @param error.bars  Plot error bars
#' @param raw.points  Plot raw data points at level of community pairs
#' @param vectors     Plot averaged vectors
#' @param all.vectors Plot vectors at level of community pairs
#' @param legend      Show legend
#' @param old.plot    ggplot object from previous \code{leap.zig()} call
#' @param main        Plot title
#' @param linetype    Type of line to draw for vector
#' @param add         Add new plot to object provided in old.plot option
#' 
#' @return A ggplot object.
#' 
#' @examples
#' 
#' # write several
#'
#' @export
#' @import ggplot2
leap.zig.both<-function(tmp, xlim=NA, ylim=NA, loc.standardize=TRUE, error.bars=FALSE,
                        raw.points=TRUE, vectors=TRUE, all.vectors=FALSE,
                        legend=TRUE, old.plot=NA, main="", linetype=1, add=FALSE){

  # Trim out un-needed factor levels
  if(raw.points == FALSE & vectors == TRUE){
    tmp[[3]]$variable <- factor(as.character(tmp[[3]]$variable),
                                levels=c("SL vector","SG vector","CDE vector","SR vector","CE vector"))
  }
  
  # Plot it:
  if(add == TRUE){
    lzp <- old.plot
  }else{
    lzp <- ggplot() + geom_hline(yintercept=0, linetype=2)
  }
  
  # Add points
  if(raw.points){
    lzp <- lzp + geom_point(data=tmp[[1]], aes(colour=variable, x=rich, y=value))
  }
  
  # Add error bars
  if(error.bars){
    lzp <- lzp + geom_errorbarh(data=tmp[[2]], aes(xmin=x.qt.lw, xmax=x.qt.up, x=mean.x, y=mean.y),
                                colour='gray', linetype=linetype) +
                 geom_errorbar(data=tmp[[2]], aes(ymin=y.qt.lw, ymax=y.qt.up, x=mean.x, y=mean.y),
                               width=1, colour='gray', linetype=linetype)
  }
  
  # Add vectors
  if(vectors){
    lzp <- lzp + geom_path(data=tmp[[3]], aes(colour=variable, x=mean.x, y=mean.y),
                           arrow=arrow(length=unit(0.2,"cm"), ends="first"), linetype=linetype)
  }
  
  if(all.vectors){
    lzp <- lzp + geom_path(data=tmp[[1]][tmp[[1]]$variable!='baseline',],
                           aes(colour=variable,x=rich,y=value), linetype=linetype,
                           arrow=arrow(length=unit(0.2,"cm"),ends="first"))
  }
  
  cols <- c(alpha('#d95f02'),alpha('#1b9e77'),alpha('#7570b3'),alpha('#7fcdbb'),alpha('#e34a33'))
  trcols <- c(alpha('#d95f02',0.1),alpha('#1b9e77',0.1),alpha('#7fcdbb',0.1),alpha('#7570b3',0.1))
  
  if(raw.points==FALSE & vectors==TRUE){
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=cols) +
                 guides(colour=guide_legend( override.aes=list(shape=c(NA,NA,NA,NA,NA), 
                                                                      linetype=c(1,1,1,1,1))))
  }else{
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=c('black',trcols,cols)) +
                 guides(colour=guide_legend( override.aes=list(
                                                                shape=c(19,1,1,1,1,NA,NA,NA,NA,NA),
                                                                linetype=c(0,0,0,0,0,1,1,1,1,1),
                                                                colour=c('black',cols[1:4],cols))))
  }
  
  # Figure out plot ranges, based on data ranges:
  xlim.D <- range(tmp[[1]]$rich)*c(0.98,1.02)
  ylim.D <- range(tmp[[1]]$value)*c(0.98,1.02)
  
  # If user supplied xlim's
  if(length(xlim) == 2){
    xlim.outer <- c(min(xlim.D[1], xlim[1]), max(xlim.D[2], xlim[2]))
    xlim.inner <- xlim
  }else{
    xlim.outer <- xlim.inner <- xlim.D
  }
  
  # If user supplied ylim's
  if(length(ylim) == 2){
    ylim.outer <- c(min(ylim.D[1], ylim[1]), max(ylim.D[2], ylim[2]))
    ylim.inner <- ylim
  }else{
    ylim.outer <- ylim.inner <- ylim.D
  }
  
  # Adjust inner plotting range
  lzp <- lzp + coord_cartesian(xlim=xlim.inner, ylim=ylim.inner)
  
  # Select color and label options:
  lzp <- lzp + theme_bw() + scale_x_continuous("Species richness", limits=xlim.outer)
  
  if(loc.standardize == TRUE){
    lzp <- lzp + scale_y_continuous("% change in EF vs. baseline", limits=ylim.outer)
  }else{
    lzp <- lzp + scale_y_continuous("Ecosystem function", limits=ylim.outer)
  }
  
  if(legend == TRUE){
    lzp <- lzp + theme(legend.title=element_blank())
  }
  
  if(legend == FALSE){
    lzp <- lzp + theme(legend.position="none")
  }
  
  lzp <- lzp + ggtitle(main)
  
  return(lzp)
}


#' Plot changes in ecosystem function using BEF components.
#'
#' This function is called by \code{\link{leap.zig()}} and produces vector plots 
#' using BEF components, overlaid on top of each other.
#'
#' @param tmp   Data to plot
#' @param xlim  Plot's x limits
#' @param ylim  Plot's y limits
#' @param loc.standarize  Are these standardized vectors
#' @param error.bars  Plot error bars
#' @param raw.points  Plot raw data points at level of community pairs
#' @param vectors     Plot averaged vectors
#' @param all.vectors Plot vectors at level of community pairs
#' @param legend      Show legend
#' @param old.plot    ggplot object from previous \code{leap.zig()} call
#' @param main        Plot title
#' @param linetype    Type of line to draw for vector
#' @param add         Add new plot to object provided in old.plot option
#' 
#' @return A ggplot object.
#' 
#' @examples
#' 
#' # write several
#'
#' @export
#' @import ggplot2
leap.zig.bef<-function(tmp, xlim=NA, ylim=NA, loc.standardize=TRUE, error.bars=FALSE,
                       raw.points=TRUE, vectors=TRUE, all.vectors=FALSE,
                       legend=TRUE, old.plot=NA, main="", linetype=1, add=FALSE){

  # Trim out un-needed factor levels
  if(raw.points == FALSE & vectors == TRUE){
    tmp[[3]]$variable <- factor(as.character(tmp[[3]]$variable), levels=c("SR vector","CE vector"))
  }
  
  # Plot it:
  if(add == TRUE){
    lzp <- old.plot
  }else{
    lzp <- ggplot()
  }
  
  # Add points
  if(raw.points){
    lzp <- lzp + geom_point(data=tmp[[1]], aes(colour=variable, x=rich, y=value))
  }
  
  # Add error bars
  if(error.bars){
    lzp <- lzp + geom_errorbarh(data=tmp[[2]], aes(xmin=x.qt.lw, xmax=x.qt.up, x=mean.x, y=mean.y),
                                colour='gray', linetype=linetype) +
                 geom_errorbar(data=tmp[[2]], aes(ymin=y.qt.lw, ymax=y.qt.up, x=mean.x, y=mean.y),
                               width=1, colour='gray', linetype=linetype)
  }
  
  # Add vectors
  if(vectors){
    lzp <- lzp + geom_path(data=tmp[[3]], aes(colour=variable, x=mean.x, y=mean.y),
                     arrow=arrow(length=unit(0.2,"cm"),ends="first"), linetype=linetype)
  }
  
  if(all.vectors){
    lzp <- lzp + geom_path(data=tmp[[1]][tmp[[1]]$variable!='baseline',],
                           aes(colour=variable, x=rich, y=value),
                           arrow=arrow(length=unit(0.2,"cm"),ends="first"), linetype=linetype)
  }
  
  cols <- c(alpha('#0000ff'),alpha('#ff00ff'))
  trcols <- c(alpha('#0000ff',0.1),alpha('#ff00ff',0.1))
  
  if(raw.points == FALSE & vectors == TRUE){
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=cols) +
                 guides(colour=guide_legend( override.aes=list(shape=c(NA,NA),linetype=c(1,1))))
  }else{
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=c('black',trcols,cols)) +
                 guides(colour=guide_legend( override.aes=list(shape=c(19,1,1,NA,NA),
                                                                      linetype=c(0,0,0,1,1),
                                                                      colour=c('black',cols,cols))))
  }
  
  # Figure out plot ranges, based on data ranges:
  xlim.D <- range(tmp[[1]]$rich)*c(0.98,1.02)
  ylim.D <- range(tmp[[1]]$value)*c(0.98,1.02)
  
  # If user supplied xlim's
  if(length(xlim)==2){
    xlim.outer <- c(min(xlim.D[1],xlim[1]), max(xlim.D[2],xlim[2]))
    xlim.inner <- xlim
  }else{
    xlim.outer <- xlim.inner <- xlim.D
  }
  
  # If user supplied ylim's
  if(length(ylim) == 2){
    ylim.outer <- c(min(ylim.D[1],ylim[1]), max(ylim.D[2],ylim[2]))
    ylim.inner <- ylim
  }else{
    ylim.outer <- ylim.inner <- ylim.D
  }
  
  # Adjust inner plotting range
  lzp <- lzp + coord_cartesian(xlim=xlim.inner, ylim=ylim.inner)
  
  # Select color and label options:
  lzp <- lzp + theme_bw() + theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank()) +
               scale_x_continuous("Species richness", limits=xlim.outer)
  
  if(loc.standardize == TRUE){
    lzp <- lzp + scale_y_continuous("% change in EF vs. baseline", limits=ylim.outer) +
                 geom_hline(yintercept=0, linetype=2)
  }else{
    lzp <- lzp + scale_y_continuous("Ecosystem function", limits=ylim.outer)
  }
  
  if(legend == TRUE){
    lzp <- lzp + theme(legend.title=element_blank())
  }
  
  if(legend == FALSE){
    lzp <- lzp + theme(legend.position="none")
  }
  
  lzp <- lzp + ggtitle(main)
  
  return(lzp)
}


#' Plot changes in ecosystem function using CAFE components.
#'
#' This function is called by \code{\link{leap.zig()}} and produces vector plots 
#' using CAFE components, overlaid on top of each other.
#'
#' @param tmp   Data to plot
#' @param xlim  Plot's x limits
#' @param ylim  Plot's y limits
#' @param loc.standarize  Are these standardized vectors
#' @param error.bars  Plot error bars
#' @param raw.points  Plot raw data points at level of community pairs
#' @param vectors     Plot averaged vectors
#' @param all.vectors Plot vectors at level of community pairs
#' @param legend      Show legend
#' @param old.plot    ggplot object from previous \code{leap.zig()} call
#' @param main        Plot title
#' @param linetype    Type of line to draw for vector
#' @param add         Add new plot to object provided in old.plot option
#' 
#' @return A ggplot object.
#' 
#' @examples
#' 
#' # write several
#'
#' @export
#' @import ggplot2
leap.zig.cafe<-function(tmp, xlim=NA, ylim=NA, loc.standardize=TRUE, error.bars=FALSE,
                        raw.points=TRUE, vectors=TRUE, all.vectors=FALSE,gp.vars=NULL,
                        legend=TRUE, old.plot=NA, main="", linetype=1, add=FALSE){
  # rename to simplify code:
  tmp3<-tmp[[3]]
  
  # Trim out un-needed factor levels
  if(raw.points == FALSE & vectors == TRUE){
    tmp3$variable <- factor(as.character(tmp3$variable), levels=c("SL vector","SG vector","CDE vector"))
  }
  
  # Set up group column?
  if(!is.null(gp.vars)){
    tmp3$gps <- data.frame(tmp3[,gp.vars])[,1]    
  }
  
  # Plot it:
  if(add == TRUE){
    lzp <- old.plot
  }else{
    lzp <- ggplot()
  }
  
  # Add points
  if(raw.points){
    lzp <- lzp + geom_point(data=tmp[[1]], aes(colour=variable, x=rich, y=value))
  }
  
  # Add error bars.
  if(error.bars){
    lzp <- lzp + geom_errorbarh(data=tmp[[2]], aes(xmin=x.qt.lw, xmax=x.qt.up, x=mean.x, y=mean.y),
                                colour='gray', linetype=linetype) +
                 geom_errorbar(data=tmp[[2]], aes(ymin=y.qt.lw, ymax=y.qt.up, x=mean.x, y=mean.y),
                               width=1, colour='gray', linetype=linetype)
  }
  
  # Add vectors
#  if(vectors){
#    lzp <- lzp + geom_path(data=tmp[[3]], aes(colour=variable, x=mean.x, y=mean.y),
#                           arrow=arrow(length=unit(0.2,"cm"), ends="first"), linetype=linetype)
#  }
  if(vectors){
    if(!is.null(gp.vars)){
      lzp <- lzp + geom_path(data=tmp3, aes(colour=variable, x=mean.x, y=mean.y,group=gps),
                             arrow=arrow(length=unit(0.2,"cm"), ends="last"), linetype=linetype)
    }else{
      lzp <- lzp + geom_path(data=tmp3, aes(colour=variable, x=mean.x, y=mean.y),
                             arrow=arrow(length=unit(0.2,"cm"), ends="last"), linetype=linetype)
    }
  }
  
  if(all.vectors){
    lzp <- lzp + geom_path(data=tmp[[1]], aes(colour=variable, x=rich, y=value, linetype=Plot),
                           arrow=arrow(length=unit(0.2,"cm"), ends="first"))
  }
  
  cols <- c(alpha('#ff0000'), alpha('#00ee00'), alpha('#900090')) 
  trcols <- c(alpha('#ff0000',0.1), alpha('#00ee00',0.1), alpha('#900090',0.1))
  
  if(raw.points==FALSE & vectors==TRUE){
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=cols) +
                 guides(colour=guide_legend( override.aes=list(shape=c(NA,NA,NA),
                                                                      linetype=c(1,1,1))))
  }else{
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=c('black',trcols,cols))+
                 guides(colour=guide_legend( override.aes=list(shape=c(19,1,1,1,NA,NA,NA),
                                                                     linetype=c(0,0,0,0,1,1,1),
                                                                     colour=c('black',cols,cols))))
  }
  
  # Figure out plot ranges, based on data ranges:
  xlim.D <- range(tmp[[1]]$rich)*c(0.98,1.02)
  ylim.D <- range(tmp[[1]]$value)*c(0.98,1.02)
  
  # If user supplied xlim's
  if(length(xlim)==2){
    xlim.outer <- c(min(xlim.D[1],xlim[1]), max(xlim.D[2],xlim[2]))
    xlim.inner <- xlim
  }else{
    xlim.outer <- xlim.inner <- xlim.D
  }
  
  # If user supplied ylim's
  if(length(ylim) == 2){
    ylim.outer <- c(min(ylim.D[1],ylim[1]), max(ylim.D[2],ylim[2]))
    ylim.inner <- ylim
  }else{
    ylim.outer <- ylim.inner <- ylim.D
  }
  
  # Adjust inner plotting range
  lzp <- lzp + coord_cartesian(xlim=xlim.inner, ylim=ylim.inner)
  
  # Select color and label options:
  lzp <- lzp + theme_bw() + theme(panel.grid.major=element_blank(), panel.grid.minor=element_blank()) +
                            scale_x_continuous("Species richness", limits=xlim.outer)
  
  if(loc.standardize == TRUE){
    lzp <- lzp + scale_y_continuous("% change in EF vs. baseline", limits=ylim.outer) +
                 geom_hline(yintercept=0, linetype=2)
  }else{
    lzp <- lzp + scale_y_continuous("Ecosystem function", limits=ylim.outer)
  }
  
  if(legend == TRUE){
    lzp <- lzp + theme(legend.title=element_blank())
  }
  
  if(legend == FALSE){
    lzp <- lzp + theme(legend.position="none")
  }
  
  lzp <- lzp + ggtitle(main)
  
  return(lzp)
}


#' Plot changes in ecosystem function using Price components.
#'
#' This function is called by \code{\link{leap.zig()}} and produces vector plots 
#' using Price components, overlaid on top of each other.
#'
#' @param tmp   Data to plot
#' @param xlim  Plot's x limits
#' @param ylim  Plot's y limits
#' @param loc.standarize  Are these standardized vectors
#' @param error.bars  Plot error bars
#' @param raw.points  Plot raw data points at level of community pairs
#' @param vectors     Plot averaged vectors
#' @param all.vectors Plot vectors at level of community pairs
#' @param legend      Show legend
#' @param old.plot    ggplot object from previous \code{leap.zig()} call
#' @param main        Plot title
#' @param linetype    Type of line to draw for vector
#' @param add         Add new plot to object provided in old.plot option
#' 
#' @return A ggplot object.
#' 
#' @examples
#' 
#' # write several
#'
#' @export
#' @import ggplot2
leap.zig.price <- function(tmp, xlim=NA, ylim=NA, loc.standardize=TRUE, error.bars=FALSE, 
                            raw.points=TRUE, vectors=TRUE, all.vectors=FALSE, 
                            legend=TRUE, old.plot=NA, main="", linetype=1, add=FALSE){
  
  # Trim out un-needed factor levels
  if(raw.points == FALSE & vectors == TRUE){
    tmp[[3]]$variable <- factor(as.character(tmp[[3]]$variable),
                                levels=c("SRE.L vector","SCE.L vector","SRE.G vector",
                                         "SCE.G vector","CDE vector"))
  }
  
  # Plot it:
  if(add == TRUE){
    lzp <- old.plot
  }else{
    lzp <- ggplot()
  }
  
  # Add points
  if(raw.points){
    lzp <- lzp + geom_point(data=tmp[[1]], aes(colour=variable, x=rich, y=value))
  }
  
  # Add error bars
  if(error.bars){
    lzp <- lzp + geom_errorbarh(data=tmp[[2]], aes(xmin=x.qt.lw, xmax=x.qt.up, x=mean.x, y=mean.y),
                                  colour='gray',linetype=linetype)+
                 geom_errorbar(data=tmp[[2]], aes(ymin=y.qt.lw, ymax=y.qt.up, x=mean.x, y=mean.y),
                                  width=1, colour='gray', linetype=linetype)
  }
  
  # Add vectors
  if(vectors){
    lzp <- lzp + geom_path(data=tmp[[3]], aes(colour=variable, x=mean.x, y=mean.y),
                              arrow=arrow(length=unit(0.2,"cm"), ends="first"), linetype=linetype)
  }
  
  if(all.vectors){
    lzp <- lzp + geom_path(data=tmp[[1]][tmp[[1]]$variable != 'baseline',],
                              aes(colour=variable, x=rich, y=value),
                              arrow=arrow(length=unit(0.2,"cm"), ends="first"), linetype=linetype)
  }
  
  cols <- c(alpha('#ff0000'), alpha('#800000'), alpha('#00ee00'), alpha('#009000'), alpha('#900090'))
  trcols <- c(alpha('#ff0000',0.1), alpha('#800000',0.1), alpha('#00ee00',0.1), 
              alpha('#009000',0.1), alpha('#900090',0.1))
  
  if(raw.points == FALSE & vectors == TRUE){
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=cols) +
                 guides(colour=guide_legend(override.aes=list(shape=c(NA,NA,NA,NA,NA),
                                                                     linetype=c(1,1,1,1,1))))
  }else{
    lzp <- lzp + scale_color_manual("Component\n", drop=FALSE, values=c('black',trcols,cols)) +
                 guides(colour=guide_legend(
                                 override.aes=list(shape=c(19,1,1,1,1,1,NA,NA,NA,NA,NA),
                                                   linetype=c(0,0,0,0,0,0,1,1,1,1,1),
                                                   colour=c('black',cols,cols))))
  }
  
  # Figure out plot ranges, based on data ranges:
  xlim.D <- range(tmp[[1]]$rich)*c(0.98,1.02)
  ylim.D <- range(tmp[[1]]$value)*c(0.98,1.02)
  
  # If user supplied xlim's
  if(length(xlim) == 2){
    xlim.outer <- c(min(xlim.D[1], xlim[1]), max(xlim.D[2], xlim[2]))
    xlim.inner <- xlim
  }else{
    xlim.outer <- xlim.inner <- xlim.D
  }
  
  # If user supplied ylim's
  if(length(ylim) == 2){
    ylim.outer <- c(min(ylim.D[1], ylim[1]), max(ylim.D[2], ylim[2]))
    ylim.inner <- ylim
  }else{
    ylim.outer <- ylim.inner <- ylim.D
  }
  
  # Adjust inner plotting range
  lzp <- lzp + coord_cartesian(xlim=xlim.inner, ylim=ylim.inner)
  
  # Select color and label options:
  lzp <- lzp + theme_bw() + theme(panel.grid.major = element_blank(), 
                                  panel.grid.minor = element_blank()) +
                            scale_x_continuous("Species richness", limits=xlim.outer)
  
  if(loc.standardize == TRUE){
    lzp <- lzp + scale_y_continuous("% change in EF vs. baseline", limits=ylim.outer) +
                 geom_hline(yintercept=0, linetype=2)
  }else{
    lzp <- lzp + scale_y_continuous("Ecosystem function", limits=ylim.outer)
  }
  
  if(legend == TRUE){
    lzp <- lzp + theme(legend.title=element_blank())
  }else{
    lzp <- lzp + theme(legend.position="none")
  }

  lzp <- lzp + ggtitle(main)
  
  return(lzp)
}
